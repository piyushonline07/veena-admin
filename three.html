<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Celestial Particle Weaver</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; }
    canvas { display: block; }
    #video-container {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 200px;
      height: 150px;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255,255,255,0.2);
      transform: scaleX(-1);
      background: #111;
    }
    .ui-panel {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      padding: 20px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.1);
      color: white;
      max-width: 320px;
      z-index: 10;
    }
    .btn-shape {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 14px;
      margin-bottom: 8px;
      width: 100%;
      text-align: left;
    }
    .btn-shape:hover { background: rgba(255,255,255,0.2); transform: translateX(5px); }
    .btn-active { border-color: #6366f1; background: rgba(99, 102, 241, 0.3); }
    .status { font-size: 12px; color: #aaa; margin-top: 10px; }
    #loading-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: #000; display: flex; flex-direction: column;
      justify-content: center; align-items: center; z-index: 100;
      color: white; transition: opacity 0.5s;
    }
    .ai-input {
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 8px;
      padding: 8px;
      width: 100%;
      color: white;
      font-size: 13px;
      outline: none;
      margin-bottom: 8px;
    }
    .ai-input:focus { border-color: #818cf8; }
    .spinner {
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      border-top: 2px solid #fff;
      width: 14px;
      height: 14px;
      animation: spin 1s linear infinite;
      display: inline-block;
      margin-right: 8px;
      vertical-align: middle;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>
</head>
<body>

<div id="loading-overlay">
  <div class="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-indigo-500 mb-4"></div>
  <p>Initializing Particle Universe...</p>
</div>

<div class="ui-panel">
  <h1 class="text-xl font-bold mb-4 bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">Particle Weaver</h1>

  <!-- Gemini Integration Section -->
  <div class="mb-6 p-3 bg-indigo-900/20 rounded-xl border border-indigo-500/30">
    <label class="text-[10px] uppercase font-bold text-indigo-300 block mb-2 tracking-wider">‚ú® AI Cosmic Vision</label>
    <input type="text" id="ai-prompt" class="ai-input" placeholder="Describe a universe..." value="A pulsar made of neon rain">
    <button id="ai-btn" class="btn-shape bg-indigo-600/40 border-indigo-400/50 hover:bg-indigo-600/60 font-medium" onclick="generateCosmicVision()">
      ‚ú® Weave Vision
    </button>
    <p id="ai-mantra" class="text-[10px] italic text-gray-400 leading-tight mt-1 min-h-[24px]">Weave your own reality...</p>
  </div>

  <div class="space-y-2">
    <button class="btn-shape btn-active" onclick="switchShape('nebula')">‚ú® Cosmic Nebula</button>
    <button class="btn-shape" onclick="switchShape('heart')">‚ù§Ô∏è Heart Chakra</button>
    <button class="btn-shape" onclick="switchShape('flower')">üå∏ Sacred Geometry Flower</button>
    <button class="btn-shape" onclick="switchShape('saturn')">ü™ê Saturn's Rings</button>
    <button class="btn-shape" onclick="switchShape('fireworks')">üéÜ Astral Fireworks</button>
    <button class="btn-shape" onclick="switchShape('shiva')">üïâÔ∏è Shiva & Universe</button>
  </div>

  <div class="mt-6 border-t border-white/10 pt-4">
    <p class="text-xs uppercase tracking-widest text-indigo-300 font-bold mb-2">Gestures</p>
    <ul class="text-[11px] space-y-1 text-gray-400">
      <li>‚Ä¢ Move Hand: Rotate system</li>
      <li>‚Ä¢ Pinch (Thumb + Index): Contract system</li>
      <li>‚Ä¢ Open Palm: Expand and Glow</li>
    </ul>
  </div>
  <div id="hand-status" class="status">Waiting for camera...</div>
</div>

<div id="video-container">
  <video id="input-video" style="width: 100%; height: 100%; object-fit: cover;"></video>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
  uniform float uTime;
  uniform float uTransition;
  uniform float uPinch;
  uniform float uSizeMult;
  attribute vec3 targetPosition;
  attribute vec3 color;
  varying vec3 vColor;
  varying float vAlpha;

  void main() {
      vec3 pos = mix(position, targetPosition, uTransition);

      // Pinch effect
      pos *= (1.0 + (1.0 - uPinch) * 0.5);

      // Slight organic movement
      pos.x += sin(uTime * 0.5 + pos.z) * 0.1;
      pos.y += cos(uTime * 0.5 + pos.x) * 0.1;

      vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);

      gl_PointSize = (15.0 / -mvPosition.z) * (1.0 + (1.0 - uPinch) * 2.0) * uSizeMult;
      gl_Position = projectionMatrix * mvPosition;

      vColor = color;
      vAlpha = 1.0 / (-mvPosition.z * 0.5);
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
  varying vec3 vColor;
  varying float vAlpha;
  uniform float uPinch;

  void main() {
      float dist = distance(gl_PointCoord, vec2(0.5));
      if (dist > 0.5) discard;

      float strength = 1.0 - (dist * 2.0);
      strength = pow(strength, 3.0);

      vec3 finalColor = vColor;
      if (uPinch < 0.5) {
          finalColor += vec3(0.2, 0.1, 0.4) * (1.0 - uPinch);
      }

      gl_FragColor = vec4(finalColor, strength * vAlpha);
  }
</script>

<script>
  const apiKey = ""; // Runtime provides this
  let scene, camera, renderer, particles, geometry, material;
  let particleCount = 25000;
  let currentShape = 'nebula';
  let targetPositions;

  // AI Config State
  let aiConfig = {
    primaryColor: { r: 0.4, g: 0.1, b: 0.8 },
    secondaryColor: { r: 1.0, g: 1.0, b: 1.0 },
    sizeMult: 1.0,
    speed: 1.0
  };

  const statusEl = document.getElementById('hand-status');
  const loadingEl = document.getElementById('loading-overlay');
  const videoElement = document.getElementById('input-video');
  const aiMantra = document.getElementById('ai-mantra');
  const aiBtn = document.getElementById('ai-btn');

  async function callGemini(prompt) {
    const systemPrompt = `You are a Cosmic AI. Transform a user's vision into technical parameters for a 3D particle system.
        Return ONLY valid JSON with this structure:
        {
          "r": float 0-1, "g": float 0-1, "b": float 0-1,
          "r2": float 0-1, "g2": float 0-1, "b2": float 0-1,
          "size": float 0.5-3.0,
          "speed": float 0.1-5.0,
          "shapeType": "nebula" | "vortex" | "sphere" | "plane",
          "mantra": "short poetic sentence"
        }`;

    const payload = {
      contents: [{ parts: [{ text: prompt }] }],
      systemInstruction: { parts: [{ text: systemPrompt }] },
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: {
          type: "OBJECT",
          properties: {
            r: { type: "NUMBER" }, g: { type: "NUMBER" }, b: { type: "NUMBER" },
            r2: { type: "NUMBER" }, g2: { type: "NUMBER" }, b2: { type: "NUMBER" },
            size: { type: "NUMBER" },
            speed: { type: "NUMBER" },
            shapeType: { type: "STRING" },
            mantra: { type: "STRING" }
          }
        }
      }
    };

    for (let i = 0; i < 5; i++) {
      try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const data = await response.json();
        return JSON.parse(data.candidates[0].content.parts[0].text);
      } catch (err) {
        await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));
      }
    }
    throw new Error("Failed to reach Gemini");
  }

  async function generateCosmicVision() {
    const prompt = document.getElementById('ai-prompt').value;
    if (!prompt) return;

    aiBtn.disabled = true;
    aiBtn.innerHTML = `<span class="spinner"></span> Weaving...`;
    aiMantra.innerText = "Consulting the stars...";

    try {
      const vision = await callGemini(prompt);

      aiConfig.primaryColor = { r: vision.r, g: vision.g, b: vision.b };
      aiConfig.secondaryColor = { r: vision.r2, g: vision.g2, b: vision.b2 };
      aiConfig.sizeMult = vision.size;
      aiConfig.speed = vision.speed;

      aiMantra.innerText = `‚ú® "${vision.mantra}"`;

      // Apply new colors to the current shape smoothly
      const colors = geometry.attributes.color.array;
      for (let i = 0; i < particleCount; i++) {
        const mix = Math.random();
        colors[i * 3] = vision.r * mix + vision.r2 * (1 - mix);
        colors[i * 3 + 1] = vision.g * mix + vision.g2 * (1 - mix);
        colors[i * 3 + 2] = vision.b * mix + vision.b2 * (1 - mix);
      }
      geometry.attributes.color.needsUpdate = true;

      // Animate size multiplier
      new TWEEN.Tween(material.uniforms.uSizeMult)
        .to({ value: vision.size }, 1000)
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();

      // Create a procedural shape variation based on shapeType
      createShape('ai_custom', vision.shapeType);
      switchShape('ai_custom');

    } catch (e) {
      aiMantra.innerText = "The connection flickered. Try again.";
    } finally {
      aiBtn.disabled = false;
      aiBtn.innerText = "‚ú® Weave Vision";
    }
  }

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 15;

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    targetPositions = new Float32Array(particleCount * 3);

    for (let i = 0; i < particleCount; i++) {
      positions[i * 3] = (Math.random() - 0.5) * 20;
      positions[i * 3 + 1] = (Math.random() - 0.5) * 20;
      positions[i * 3 + 2] = (Math.random() - 0.5) * 20;
      colors[i * 3] = 0.5; colors[i * 3 + 1] = 0.2; colors[i * 3 + 2] = 0.8;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    geometry.setAttribute('targetPosition', new THREE.BufferAttribute(new Float32Array(positions), 3));

    material = new THREE.ShaderMaterial({
      vertexShader: document.getElementById('vertexShader').textContent,
      fragmentShader: document.getElementById('fragmentShader').textContent,
      uniforms: {
        uTime: { value: 0 },
        uTransition: { value: 0 },
        uPinch: { value: 1.0 },
        uSizeMult: { value: 1.0 }
      },
      transparent: true,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });

    particles = new THREE.Points(geometry, material);
    scene.add(particles);

    window.addEventListener('resize', onWindowResize, false);
    createShape('nebula');
    animate();
    setupMediaPipe();
  }

  function createShape(type, subtype = 'vortex') {
    const targets = geometry.attributes.targetPosition.array;

    for (let i = 0; i < particleCount; i++) {
      let x, y, z;
      if (type === 'ai_custom') {
        if (subtype === 'vortex') {
          const angle = i * 0.05;
          const rad = 0.1 * Math.sqrt(i);
          x = rad * Math.cos(angle);
          y = (i / particleCount) * 10 - 5;
          z = rad * Math.sin(angle);
        } else if (subtype === 'plane') {
          x = (Math.random() - 0.5) * 20;
          y = (Math.random() - 0.5) * 20;
          z = Math.sin(x * 0.5) * Math.cos(y * 0.5) * 2;
        } else { // sphere
          const phi = Math.random() * Math.PI * 2;
          const theta = Math.random() * Math.PI;
          const rad = 7;
          x = rad * Math.sin(theta) * Math.cos(phi);
          y = rad * Math.sin(theta) * Math.sin(phi);
          z = rad * Math.cos(theta);
        }
      } else if (type === 'heart') {
        const t = Math.random() * Math.PI * 2;
        x = 16 * Math.pow(Math.sin(t), 3);
        y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
        z = (Math.random() - 0.5) * 5;
        x *= 0.35; y *= 0.35; z *= 0.35;
      } else if (type === 'flower') {
        const angle = i * 0.1;
        const radius = 0.2 * Math.sqrt(i);
        x = radius * Math.cos(angle);
        y = radius * Math.sin(angle);
        z = Math.sin(radius * 0.5) * 2.0;
      } else if (type === 'saturn') {
        if (i < particleCount * 0.4) {
          const phi = Math.random() * Math.PI * 2;
          const theta = Math.random() * Math.PI;
          x = 4 * Math.sin(theta) * Math.cos(phi);
          y = 4 * Math.sin(theta) * Math.sin(phi);
          z = 4 * Math.cos(theta);
        } else {
          const angle = Math.random() * Math.PI * 2;
          const rad = 6 + Math.random() * 3;
          x = rad * Math.cos(angle);
          y = (Math.random() - 0.5) * 0.5;
          z = rad * Math.sin(angle);
        }
      } else if (type === 'shiva') {
        if (i < particleCount * 0.3) {
          const angle = Math.random() * Math.PI * 2;
          x = 9 * Math.cos(angle);
          y = 9 * Math.sin(angle);
          z = (Math.random() - 0.5) * 0.5;
        } else {
          const py = (Math.random() - 0.5) * 14;
          const width = 3 * Math.cos(py/10);
          const angle = Math.random() * Math.PI * 2;
          x = Math.cos(angle) * width * Math.random();
          y = py;
          z = Math.sin(angle) * width * Math.random();
        }
      } else if (type === 'fireworks') {
        const dist = Math.random() * 8;
        const angle = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;
        x = dist * Math.sin(phi) * Math.cos(angle);
        y = dist * Math.sin(phi) * Math.sin(angle);
        z = dist * Math.cos(phi);
      } else {
        x = (Math.random() - 0.5) * 20;
        y = (Math.random() - 0.5) * 20;
        z = (Math.random() - 0.5) * 20;
      }

      targets[i * 3] = x;
      targets[i * 3 + 1] = y;
      targets[i * 3 + 2] = z;
    }
    geometry.attributes.targetPosition.needsUpdate = true;
  }

  function switchShape(type) {
    if (type !== 'ai_custom') {
      document.querySelectorAll('.btn-shape').forEach(b => b.classList.remove('btn-active'));
      if (event && event.target) event.target.classList.add('btn-active');
      createShape(type);
    }

    currentShape = type;
    new TWEEN.Tween({ t: 0 }).to({ t: 1 }, 1500).easing(TWEEN.Easing.Quadratic.InOut)
      .onUpdate((obj) => material.uniforms.uTransition.value = obj.t)
      .onComplete(() => {
        const pos = geometry.attributes.position.array;
        const tar = geometry.attributes.targetPosition.array;
        for(let i=0; i < pos.length; i++) pos[i] = tar[i];
        geometry.attributes.position.needsUpdate = true;
        material.uniforms.uTransition.value = 0;
      }).start();
  }

  function setupMediaPipe() {
    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);
    const cam = new Camera(videoElement, {
      onFrame: async () => { await hands.send({ image: videoElement }); },
      width: 640, height: 480
    });
    cam.start().then(() => {
      loadingEl.style.opacity = '0';
      setTimeout(() => loadingEl.style.display = 'none', 500);
    });
  }

  function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
      statusEl.innerText = "Hand Active";
      statusEl.style.color = "#4f46e5";
      const hand = results.multiHandLandmarks[0];
      particles.rotation.y = THREE.MathUtils.lerp(particles.rotation.y, (hand[9].x - 0.5) * Math.PI * 2, 0.1);
      particles.rotation.x = THREE.MathUtils.lerp(particles.rotation.x, (hand[9].y - 0.5) * Math.PI, 0.1);
      const dist = Math.sqrt(Math.pow(hand[4].x-hand[8].x,2)+Math.pow(hand[4].y-hand[8].y,2));
      material.uniforms.uPinch.value = THREE.MathUtils.lerp(material.uniforms.uPinch.value, Math.max(0, Math.min(1, dist * 5)), 0.2);
      camera.position.z = THREE.MathUtils.lerp(camera.position.z, 15 + hand[0].z * -50, 0.05);
    } else {
      statusEl.innerText = "No hand detected";
      statusEl.style.color = "#aaa";
      material.uniforms.uPinch.value = THREE.MathUtils.lerp(material.uniforms.uPinch.value, 1.0, 0.05);
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();
    material.uniforms.uTime.value += 0.01 * aiConfig.speed;
    particles.rotation.z += 0.001;
    renderer.render(scene, camera);
  }

  window.onload = init;
</script>

</body>
</html>
